{"links":[{"end":"RenderOutput","filter":"Linear","slot":0,"start":"Image","wrapMode":"Repeat"}],"metadata":{"Author":"benraziel","Description":"A version of Flappy Bird running in a pixel shader. \nIts a dirty job but someone's gotta do it =)\nBased on the excellent \"Super Mario Bros\" shader by HLorenzi - https://www.shadertoy.com/view/Msj3zD","Name":"FlappyBird","ShaderToyURL":"https://www.shadertoy.com/view/ldjGzt"},"nodes":[{"class":"RenderOutput","name":"RenderOutput"},{"class":"GLSLShader","name":"Image","source":"// FlappyBird by Ben Raziel. Feb 2014\n\n// Based on the \"Super Mario Bros\" shader by HLorenzi\n// https://www.shadertoy.com/view/Msj3zD\n\n// Helper functions for drawing sprites\n#define RGB(r,g,b) vec4(float(r)/255.0,float(g)/255.0,float(b)/255.0,1.0)\n#define SPRROW(x,a,b,c,d,e,f,g,h, i,j,k,l,m,n,o,p) (x <= 7 ? SPRROW_H(a,b,c,d,e,f,g,h) : SPRROW_H(i,j,k,l,m,n,o,p))\n#define SPRROW_H(a,b,c,d,e,f,g,h) (a+4.0*(b+4.0*(c+4.0*(d+4.0*(e+4.0*(f+4.0*(g+4.0*(h))))))))\n#define SECROW(x,a,b,c,d,e,f,g,h) (x <= 3 ? SECROW_H(a,b,c,d) : SECROW_H(e,f,g,h))\n#define SECROW_H(a,b,c,d) (a+8.0*(b+8.0*(c+8.0*(d))))\n#define SELECT(x,i) mod(floor(i/pow(4.0,float(x))),4.0)\n#define SELECTSEC(x,i) mod(floor(i/pow(8.0,float(x))),8.0)\n\n// drawing consts\nconst float PIPE_WIDTH = 26.0; // px\nconst float PIPE_BOTTOM = 39.0; // px\nconst float PIPE_HOLE_HEIGHT = 12.0; // px\nconst vec4 PIPE_OUTLINE_COLOR = RGB(84, 56, 71);\n\n// gameplay consts\nconst float HORZ_PIPE_DISTANCE = 100.0; // px;\nconst float VERT_PIPE_DISTANCE = 55.0; // px;\nconst float PIPE_MIN = 20.0;\nconst float PIPE_MAX = 70.0;\t\nconst float PIPE_PER_CYCLE = 8.0;\t\n\nvec4 fragColor;\n\nvoid drawHorzRect(float yCoord, float minY, float maxY, vec4 color)\n{\n\tif ((yCoord >= minY) && (yCoord < maxY)) {\n\t\tfragColor = color;\t\t\n\t}\n}\n\nvoid drawLowBush(int x, int y)\n{\n\tif (y < 0 || y > 3 || x < 0 || x > 15) {\n\t\treturn;\n\t}\n\t\n\tfloat col = 0.0; // 0 = transparent\n\n\tif (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,0.,0.,1.,1.,2.,2., 2.,2.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,1.,1.,2.,2.,2., 2.,2.,2.,1.,1.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,1.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,1.,0.,0.);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(87,201,111);\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(100,224,117);\n\t}\n}\n\nvoid drawHighBush(int x, int y)\n{\n\tif (y < 0 || y > 6 || x < 0 || x > 15) {\n\t\treturn;\n\t}\n\t\n\tfloat col = 0.0; // 0 = transparent\n\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,0.,0.,0.,1.,1.,2.,2., 2.,2.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,1.,1.,2.,2.,2.,2., 2.,2.,2.,2.,1.,1.,0.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  1) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);\n\tif (y ==  0) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);\n\t\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(87,201,111);\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(100,224,117);\n\t}\n}\n\nvoid drawCloud(int x, int y)\n{\n\tif (y < 0 || y > 6 || x < 0 || x > 15) {\n\t\treturn;\n\t}\n\t\n\tfloat col = 0.0; // 0 = transparent\n\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,0.,0.,0.,1.,1.,2.,2., 2.,2.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,1.,1.,2.,2.,2.,2., 2.,2.,2.,2.,1.,1.,0.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  1) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);\n\tif (y ==  0) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);\n\t\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(218,246,216);\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(233,251,218);\n\t}\n}\n\nvoid drawBirdF0(int x, int y)\n{\n\tif (y < 0 || y > 11 || x < 0 || x > 15) {\n\t\treturn;\n\t}\n\t\n\t// pass 0 - draw black, white and yellow\n\tfloat col = 0.0; // 0 = transparent\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,1.,1.,3.,3., 3.,1.,2.,2.,1.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,1.,3.,3.,3.,3., 1.,2.,2.,2.,2.,1.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);\n\tif (y ==  7) col = SPRROW(x,0.,1.,3.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,1.,3.,3.,3.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,1.,1.,1.,1.,1.,3.,3., 3.,3.,1.,1.,1.,1.,1.,1.);\n\tif (y ==  4) col = SPRROW(x,1.,2.,2.,2.,2.,2.,1.,3., 3.,1.,2.,2.,2.,2.,2.,1.);\n\tif (y ==  3) col = SPRROW(x,1.,2.,2.,2.,2.,1.,3.,3., 1.,2.,1.,1.,1.,1.,1.,1.);\n\tif (y ==  2) col = SPRROW(x,1.,2.,2.,2.,1.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,1.,1.,1.,1.,3.,3.,3., 3.,3.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\t\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(82,56,70); // outline color (black)\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(250,250,250); // eye color (white)\n\t}\n\telse if (col == 3.0) {\n\t\tfragColor = RGB(247, 182, 67); // normal yellow color\n\t}\n\t\n\t// pass 1 - draw red, light yellow and dark yellow\n\tcol = 0.0; // 0 = transparent\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,0.,0.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,0.,3.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,3.,0.,0.,0.,3.,0.,0., 0.,0.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,0.,2.,2., 0.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,0.,3.,0.,2.,2.,2., 2.,0.,1.,1.,1.,1.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\t\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(249, 58, 28); // mouth color (red)\t\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(222, 128, 55); // brown\n\t}\n\telse if (col == 3.0) {\n\t\tfragColor = RGB(249, 214, 145); // light yellow\t\t\t\n\t}\t\t\n}\n\nvoid drawBirdF1(int x, int y)\n{\n\tif (y < 0 || y > 11 || x < 0 || x > 15) {\n\t\treturn;\n\t}\n\t\n\t// pass 0 - draw black, white and yellow\n\tfloat col = 0.0; // 0 = transparent\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,1.,1.,3.,3., 3.,1.,2.,2.,1.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,1.,3.,3.,3.,3., 1.,2.,2.,2.,2.,1.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);\n\tif (y ==  7) col = SPRROW(x,0.,1.,3.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,1.,1.,1.,1.,1.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  5) col = SPRROW(x,1.,2.,2.,2.,2.,2.,1.,3., 3.,3.,1.,1.,1.,1.,1.,1.);\n\tif (y ==  4) col = SPRROW(x,1.,2.,2.,2.,2.,2.,1.,3., 3.,1.,2.,2.,2.,2.,2.,1.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,1.,1.,1.,1.,3.,3., 1.,2.,1.,1.,1.,1.,1.,1.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,1.,1.,3.,3.,3., 3.,3.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\t\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(82,56,70); // outline color (black)\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(250,250,250); // eye color (white)\n\t}\n\telse if (col == 3.0) {\n\t\tfragColor = RGB(247, 182, 67); // normal yellow color\n\t}\n\t\n\t// pass 1 - draw red, light yellow and dark yellow\n\tcol = 0.0; // 0 = transparent\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,0.,0.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,0.,3.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,3.,0.,0.,0.,3.,0.,0., 0.,0.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,0.,2.,2., 0.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,0.,2.,2.,2.,2.,2., 2.,0.,1.,1.,1.,1.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\t\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(249, 58, 28); // mouth color (red)\t\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(222, 128, 55); // brown\n\t}\n\telse if (col == 3.0) {\n\t\tfragColor = RGB(249, 214, 145); // light yellow\t\t\t\n\t}\t\t\n}\n\nvoid drawBirdF2(int x, int y)\n{\n\tif (y < 0 || y > 11 || x < 0 || x > 15) {\n\t\treturn;\n\t}\n\t\n\t// pass 0 - draw black, white and yellow\n\tfloat col = 0.0; // 0 = transparent\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,1.,1.,3.,3., 3.,1.,2.,2.,1.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,1.,3.,3.,3.,3., 1.,2.,2.,2.,2.,1.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,1.,1.,1.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);\n\tif (y ==  7) col = SPRROW(x,1.,2.,2.,2.,1.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);\n\tif (y ==  6) col = SPRROW(x,1.,2.,2.,2.,2.,1.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  5) col = SPRROW(x,1.,2.,2.,2.,2.,1.,3.,3., 3.,3.,1.,1.,1.,1.,1.,1.);\n\tif (y ==  4) col = SPRROW(x,0.,1.,2.,2.,2.,1.,3.,3., 3.,1.,2.,2.,2.,2.,2.,1.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,1.,1.,1.,3.,3.,3., 1.,2.,1.,1.,1.,1.,1.,1.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,1.,1.,3.,3.,3., 3.,3.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\t\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(82,56,70); // outline color (black)\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(250,250,250); // eye color (white)\n\t}\n\telse if (col == 3.0) {\n\t\tfragColor = RGB(247, 182, 67); // normal yellow color\n\t}\n\t\n\t// pass 1 - draw red, light yellow and dark yellow\n\tcol = 0.0; // 0 = transparent\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,0.,0.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,3.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,3.,3.,3.,0.,0.,0., 0.,0.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 0.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,0.,2.,2.,2.,2.,2., 2.,0.,1.,1.,1.,1.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\t\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 1.0) {\n\t\tfragColor = RGB(249, 58, 28); // mouth color (red)\t\n\t}\n\telse if (col == 2.0) {\n\t\tfragColor = RGB(222, 128, 55); // brown\n\t}\n\telse if (col == 3.0) {\n\t\tfragColor = RGB(249, 214, 145); // light yellow\t\t\t\n\t}\t\t\n}\n\nvec2 getLevelPixel(vec2 fragCoord)\n{\n\t// Get the current game pixel\n\t// (Each game pixel is two screen pixels)\n\t//  (or four, if the screen is larger)\n\tfloat x = fragCoord.x / 2.0;\n\tfloat y = fragCoord.y / 2.0;\n\t\n\tif (iResolution.y >= 640.0) {\n\t\tx /= 2.0;\n\t\ty /= 2.0;\n\t}\n\t\n\tif (iResolution.y < 200.0) {\n\t\tx *= 2.0;\n\t\ty *= 2.0;\n\t}\n\t\n\treturn vec2(x,y);\n}\n\nvec2 getLevelBounds()\n{\n\t// same logic as getLevelPixel, but returns the boundaries of the screen\n\n\tfloat x = iResolution.x / 2.0;\n\tfloat y = iResolution.y / 2.0;\n\t\n\tif (iResolution.y >= 640.0) {\n\t\tx /= 2.0;\n\t\ty /= 2.0;\n\t}\n\t\n\tif (iResolution.y < 200.0) {\n\t\tx *= 2.0;\n\t\ty *= 2.0;\n\t}\n\t\n\treturn vec2(x,y);\n}\n\nvoid drawGround(vec2 co)\n{\n\tdrawHorzRect(co.y, 0.0, 31.0, RGB(221, 216, 148));\n\tdrawHorzRect(co.y, 31.0, 32.0, RGB(208, 167, 84)); // shadow below the green sprites\n}\n\nvoid drawGreenStripes(vec2 co)\n{\n\tint f = int(mod(iTime * 60.0, 6.0));\n\t\n\tdrawHorzRect(co.y, 32.0, 33.0, RGB(86, 126, 41)); // shadow blow\n\t\n\tconst float MIN_Y = 33.0;\n\tconst float HEIGHT = 6.0;\n\t\n\tvec4 darkGreen  = RGB(117, 189, 58);\n\tvec4 lightGreen = RGB(158, 228, 97);\n\t\n\t// draw diagonal stripes, and animate them\n\tif ((co.y >= MIN_Y) && (co.y < MIN_Y+HEIGHT)) {\n\t\tfloat yPos = co.y - MIN_Y - float(f);\n\t\tfloat xPos = mod((co.x - yPos), HEIGHT);\n\t\t\n\t\tif (xPos >= HEIGHT / 2.0) {\n\t\t\tfragColor = darkGreen;\n\t\t}\n\t\telse {\n\t\t\tfragColor = lightGreen;\n\t\t}\n\t}\n\t\n\tdrawHorzRect(co.y, 37.0, 38.0, RGB(228, 250, 145)); // shadow highlight above\n\tdrawHorzRect(co.y, 38.0, 39.0, RGB(84, 56, 71)); // black separator\t\n}\n\t\nvoid drawTile(int type, vec2 tileCorner, vec2 co)\n{\n\tif ((co.x < tileCorner.x) || (co.x > (tileCorner.x + 16.0)) ||\n\t\t(co.y < tileCorner.y) || (co.y > (tileCorner.y + 16.0)))\n\t{\n\t\treturn;\t\n\t}\n\t\n\tint modX = int(mod(co.x - tileCorner.x, 16.0));\n\tint modY = int(mod(co.y - tileCorner.y, 16.0));\n\t\t\t\t\n\tif (type == 0){\n\t\tdrawLowBush(modX, modY);\n\t}\n\telse if (type == 1) {\n\t\tdrawHighBush(modX, modY);\n\t}\n\telse if (type == 2) {\n\t\tdrawCloud(modX, modY);\n\t}\n\telse if (type == 3) {\n\t\tdrawBirdF0(modX, modY);\n\t}\n\telse if (type == 4) {\n\t\tdrawBirdF1(modX, modY);\n\t}\n\telse if (type == 5) {\n\t\tdrawBirdF2(modX, modY);\n\t}\n}\n\nvoid drawVertLine(vec2 co, float xPos, float yStart, float yEnd, vec4 color)\n{\n\tif ((co.x >= xPos) && (co.x < (xPos + 1.0)) && (co.y >= yStart) && (co.y < yEnd)) {\n\t\tfragColor = color;\n\t}\n}\n\nvoid drawHorzLine(vec2 co, float yPos, float xStart, float xEnd, vec4 color)\n{\n\tif ((co.y >= yPos) && (co.y < (yPos + 1.0)) && (co.x >= xStart) && (co.x < xEnd)) {\n\t\tfragColor = color;\n\t}\n}\n\nvoid drawHorzGradientRect(vec2 co, vec2 bottomLeft, vec2 topRight, vec4 leftColor, vec4 rightColor)\n{\n\tif ((co.x < bottomLeft.x) || (co.y < bottomLeft.y) ||\n\t\t(co.x > topRight.x) || (co.y > topRight.y))\n\t{\n\t\treturn;\t\n\t}\n\t\n\tfloat distanceRatio = (co.x - bottomLeft.x) / (topRight.x - bottomLeft.x); \n\t\n\tfragColor = (1.0 - distanceRatio) * leftColor + distanceRatio * rightColor;\n}\n\nvoid drawBottomPipe(vec2 co, float xPos, float height)\n{\t\n\tif ((co.x < xPos) || (co.x > (xPos + PIPE_WIDTH)) ||\n\t\t(co.y < PIPE_BOTTOM) || (co.y > (PIPE_BOTTOM + height)))\n\t{\n\t\treturn;\n\t}\n\t\n\t// draw the bottom part of the pipe\n\t// outlines\n\tfloat bottomPartEnd = PIPE_BOTTOM - PIPE_HOLE_HEIGHT + height;\n\tdrawVertLine(co, xPos+1.0, PIPE_BOTTOM, bottomPartEnd, PIPE_OUTLINE_COLOR);\n\tdrawVertLine(co, xPos+PIPE_WIDTH-2.0, PIPE_WIDTH, bottomPartEnd, PIPE_OUTLINE_COLOR);\n\t\n\t// gradient fills\n\tdrawHorzGradientRect(co, vec2(xPos+2.0, PIPE_BOTTOM), vec2(xPos + 10.0, bottomPartEnd), RGB(133, 168, 75), RGB(228, 250, 145)); \n\tdrawHorzGradientRect(co, vec2(xPos+10.0, PIPE_BOTTOM), vec2(xPos + 20.0, bottomPartEnd), RGB(228, 250, 145), RGB(86, 126, 41)); \n\tdrawHorzGradientRect(co, vec2(xPos+20.0, PIPE_BOTTOM), vec2(xPos + 24.0, bottomPartEnd), RGB(86, 126, 41), RGB(86, 126, 41));\n\t\n\t// shadows\n\tdrawHorzLine(co, bottomPartEnd - 1.0, xPos + 2.0, xPos+PIPE_WIDTH-2.0, RGB(86, 126, 41));\n\t\n\t// draw the pipe opening\n\t// outlines\n\tdrawVertLine(co, xPos, bottomPartEnd, bottomPartEnd + PIPE_HOLE_HEIGHT, PIPE_OUTLINE_COLOR);\n\tdrawVertLine(co, xPos+PIPE_WIDTH-1.0, bottomPartEnd, bottomPartEnd + PIPE_HOLE_HEIGHT, PIPE_OUTLINE_COLOR);\t\n\tdrawHorzLine(co, bottomPartEnd, xPos, xPos+PIPE_WIDTH-1.0, PIPE_OUTLINE_COLOR);\n\tdrawHorzLine(co, bottomPartEnd + PIPE_HOLE_HEIGHT-1.0, xPos, xPos+PIPE_WIDTH-1.0, PIPE_OUTLINE_COLOR);\n\n\t// gradient fills\n\tfloat gradientBottom = bottomPartEnd + 1.0;\n\tfloat gradientTop = bottomPartEnd + PIPE_HOLE_HEIGHT - 1.0;\n\tdrawHorzGradientRect(co, vec2(xPos+1.0, gradientBottom), vec2(xPos + 5.0, gradientTop), RGB(221, 234, 131), RGB(228, 250, 145)); \n\tdrawHorzGradientRect(co, vec2(xPos+5.0, gradientBottom), vec2(xPos + 22.0, gradientTop), RGB(228, 250, 145), RGB(86, 126, 41)); \n\tdrawHorzGradientRect(co, vec2(xPos+22.0, gradientBottom), vec2(xPos + 25.0, gradientTop), RGB(86, 126, 41), RGB(86, 126, 41));\n\t\n\t// shadows\n\tdrawHorzLine(co, gradientBottom, xPos+1.0, xPos+25.0, RGB(86, 126, 41));\n\tdrawHorzLine(co, gradientTop-1.0, xPos+1.0, xPos+25.0, RGB(122, 158, 67));\n}\n\nvoid drawTopPipe(vec2 co, float xPos, float height)\n{\t\n\tvec2 bounds = getLevelBounds();\n\t\n\tif ((co.x < xPos) || (co.x > (xPos + PIPE_WIDTH)) ||\n\t\t(co.y < (bounds.y - height)) || (co.y > bounds.y))\n\t{\n\t\treturn;\n\t}\n\t\n\t// draw the bottom part of the pipe\n\t// outlines\n\tfloat bottomPartEnd = bounds.y + PIPE_HOLE_HEIGHT - height;\n\tdrawVertLine(co, xPos+1.0, bottomPartEnd, bounds.y, PIPE_OUTLINE_COLOR);\n\tdrawVertLine(co, xPos+PIPE_WIDTH-2.0, bottomPartEnd, bounds.y, PIPE_OUTLINE_COLOR);\n\t\n\t// gradient fills\n\tdrawHorzGradientRect(co, vec2(xPos+2.0, bottomPartEnd), vec2(xPos + 10.0, bounds.y), RGB(133, 168, 75), RGB(228, 250, 145)); \n\tdrawHorzGradientRect(co, vec2(xPos+10.0, bottomPartEnd), vec2(xPos + 20.0, bounds.y), RGB(228, 250, 145), RGB(86, 126, 41)); \n\tdrawHorzGradientRect(co, vec2(xPos+20.0, bottomPartEnd), vec2(xPos + 24.0, bounds.y), RGB(86, 126, 41), RGB(86, 126, 41));\n\t\n\t// shadows\n\tdrawHorzLine(co, bottomPartEnd+1.0, xPos + 2.0, xPos+PIPE_WIDTH-2.0, RGB(86, 126, 41));\n\t\n\t// draw the pipe opening\n\t// outlines\n\tdrawVertLine(co, xPos, bottomPartEnd - PIPE_HOLE_HEIGHT, bottomPartEnd, PIPE_OUTLINE_COLOR);\n\tdrawVertLine(co, xPos+PIPE_WIDTH-1.0, bottomPartEnd - PIPE_HOLE_HEIGHT, bottomPartEnd, PIPE_OUTLINE_COLOR);\t\n\tdrawHorzLine(co, bottomPartEnd, xPos, xPos+PIPE_WIDTH, PIPE_OUTLINE_COLOR);\n\tdrawHorzLine(co, bottomPartEnd - PIPE_HOLE_HEIGHT, xPos, xPos+PIPE_WIDTH-1.0, PIPE_OUTLINE_COLOR);\n\t\t\n\t// gradient fills\n\tfloat gradientBottom = bottomPartEnd - PIPE_HOLE_HEIGHT + 1.0;\n\tfloat gradientTop = bottomPartEnd;\n\tdrawHorzGradientRect(co, vec2(xPos+1.0, gradientBottom), vec2(xPos + 5.0, gradientTop), RGB(221, 234, 131), RGB(228, 250, 145)); \n\tdrawHorzGradientRect(co, vec2(xPos+5.0, gradientBottom), vec2(xPos + 22.0, gradientTop), RGB(228, 250, 145), RGB(86, 126, 41)); \n\tdrawHorzGradientRect(co, vec2(xPos+22.0, gradientBottom), vec2(xPos + 25.0, gradientTop), RGB(86, 126, 41), RGB(86, 126, 41));\n\t\n\t// shadows\n\tdrawHorzLine(co, gradientBottom, xPos+1.0, xPos+25.0, RGB(122, 158, 67));\n\tdrawHorzLine(co, gradientTop-1.0, xPos+1.0, xPos+25.0, RGB(86, 126, 41));\n}\n\nvoid drawBushGroup(vec2 bottomCorner, vec2 co)\n{\n\tdrawTile(0, bottomCorner, co);\n\tbottomCorner.x += 13.0;\n\t\n\tdrawTile(1, bottomCorner, co);\n\tbottomCorner.x += 13.0;\n\t\n\tdrawTile(0, bottomCorner, co);\t\n}\n\nvoid drawBushes(vec2 co)\n{\n\tdrawHorzRect(co.y, 39.0, 70.0, RGB(100, 224, 117));\n\t\n\tfor (int i = 0; i < 20; i++) {\n\t\tfloat xOffset = float(i) * 45.0;\n\t\tdrawBushGroup(vec2(xOffset, 70.0), co);\n\t\tdrawBushGroup(vec2(xOffset+7.0, 68.0), co);\n\t\tdrawBushGroup(vec2(xOffset-16.0, 65.0), co);\n\t}\n}\n\nvoid drawClouds(vec2 co)\n{\n\tfor (int i = 0; i < 20; i++) {\n\t\tfloat xOffset = float(i) * 40.0;\n\t\tdrawTile(2, vec2(xOffset, 95.0), co);\n\t\tdrawTile(2, vec2(xOffset+14.0, 91.0), co);\n\t\tdrawTile(2, vec2(xOffset+28.0, 93.0), co);\n\t}\n\n\tdrawHorzRect(co.y, 70.0, 95.0, RGB(233,251,218));\n}\n\nvoid drawPipePair(vec2 co, float xPos, float bottomPipeHeight)\n{\n\tvec2 bounds = getLevelBounds();\n\tfloat topPipeHeight = bounds.y - (VERT_PIPE_DISTANCE + PIPE_BOTTOM + bottomPipeHeight);\n\t\n\tdrawBottomPipe(co, xPos, bottomPipeHeight);\n\tdrawTopPipe(co, xPos, topPipeHeight);\t\n}\n\nvoid drawPipes(vec2 co)\n{\n\t// calculate the starting position of the pipes according to the current frame\n\tfloat animationCycleLength = HORZ_PIPE_DISTANCE * PIPE_PER_CYCLE; // the number of frames after which the animation should repeat itself\n\tint f = int(mod(iTime * 60.0, animationCycleLength));\n\tfloat xPos = -float(f);\n\t\n\tfloat center = (PIPE_MAX + PIPE_MIN) / 2.0; \n\tfloat halfTop = (center + PIPE_MAX) / 2.0;\n\tfloat halfBottom = (center + PIPE_MIN) / 2.0;\t\n\t\n\tfor (int i = 0; i < 12; i++)\n\t{\t\n\t\tfloat yPos = center;\n\t\tint cycle = int(mod(float(i),8.0));\n\t\t\n\t\tif ((cycle == 1) || (cycle == 3)){\n\t\t\tyPos = halfTop;\n\t\t}\n\t\telse if (cycle == 2) {\n\t\t\tyPos = PIPE_MAX;\t\n\t\t}\n\t\telse if ((cycle == 5) || (cycle == 7)) {\n\t\t\tyPos = halfBottom;\n\t\t}\n\t\telse if (cycle == 6){\n\t\t\tyPos = PIPE_MIN;\n\t\t}\n\t\t\t\n\t\tdrawPipePair(co, xPos, yPos);\n\t\txPos += HORZ_PIPE_DISTANCE;\n\t}\n}\n\nvoid drawBird(vec2 co)\n{\n\tfloat animationCycleLength = HORZ_PIPE_DISTANCE * PIPE_PER_CYCLE; // the number of frames after which the animation should repeat itself\n\tint cycleFrame = int(mod(iTime * 60.0, animationCycleLength));\n\tfloat fCycleFrame = float(cycleFrame);\t\n\t\n\tconst float START_POS = 110.0;\n\tconst float SPEED = 2.88;\n\tconst float UPDOWN_DELTA = 0.16;\n\tconst float ACCELERATION = -0.0975;\n\tfloat jumpFrame = float(int(mod(iTime * 60.0, 30.0)));\n\tint horzDist = int(HORZ_PIPE_DISTANCE);\n\t\n\t// calculate the \"jumping\" effect on the Y axis.\n\t// Using equations of motion, const acceleration: x = x0 + v0*t + 1/2at^2  \n\tfloat yPos = START_POS + SPEED * jumpFrame + ACCELERATION * pow(jumpFrame, 2.0);\n\t\n\tfloat speedDelta = UPDOWN_DELTA * mod(fCycleFrame, HORZ_PIPE_DISTANCE);\n\tint prevUpCycles = 0;\n\tint prevDownCycles = 0;\n\t\n\t// count the number of pipes we've already passed. \n\t// for each such pipe, we deduce if we went \"up\" or \"down\" in Y\n\tint cycleCount = int(fCycleFrame / HORZ_PIPE_DISTANCE);\n\t\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (i <= cycleCount) {\n\t\t\tif (i == 1) {\n\t\t\t\tprevUpCycles++;\n\t\t\t}\n\t\t\t\n\t\t\tif ((i >= 2) && (i < 6)) {\n\t\t\t\tprevDownCycles++;\t\n\t\t\t}\n\t\t\tif (i >= 6) {\n\t\t\t\tprevUpCycles++;\n\t\t\t}\t\t\n\t\t}\n\t}\n\t\n\t// add up/down delta from all the previous pipes\n\tyPos += ((float(prevUpCycles - prevDownCycles)) * HORZ_PIPE_DISTANCE * UPDOWN_DELTA);\n\t\n\t// calculate the up/down delta for the current two pipes, and add it to the previous result\n\tif (((cycleFrame >= 0) && (cycleFrame < horzDist)) ||\n\t\t((cycleFrame >= 5*horzDist) && (cycleFrame < 9*horzDist))) {\n\t\tyPos += speedDelta;\n\t}\n\telse {\n\t\tyPos -= speedDelta;\t\n\t}\t\n\t\n\tint animFrame = int(mod(iTime * 7.0, 3.0));\n\tif (animFrame == 0) drawTile(3, vec2(105, int(yPos)), co);\n\tif (animFrame == 1) drawTile(4, vec2(105, int(yPos)), co);\n\tif (animFrame == 2) drawTile(5, vec2(105, int(yPos)), co);\n}\n\nvoid mainImage( out vec4 iFragColor, in vec2 fragCoord )\n{\t\n\tvec2 levelPixel = getLevelPixel(fragCoord);\n\t\n\tfragColor = RGB(113, 197, 207); \t// draw the blue sky background\n\t\n\tdrawGround(levelPixel);\t\n\tdrawGreenStripes(levelPixel);\n\tdrawClouds(levelPixel);\n\tdrawBushes(levelPixel);\n\tdrawPipes(levelPixel);\n\tdrawBird(levelPixel);\n    \n    iFragColor = fragColor;\n}\n","type":"Image"}]}