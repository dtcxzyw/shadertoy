{"links":[{"end":"RenderOutput","filter":"Linear","slot":0,"start":"Image","wrapMode":"Repeat"}],"metadata":{"Author":"NuSan","Description":"Live coded for Inercia Shader Royale 2022 - 3rd place\n","Name":"Shader Royale 2022 - NuSan","ShaderToyURL":"https://www.shadertoy.com/view/md23WD"},"nodes":[{"class":"RenderOutput","name":"RenderOutput"},{"class":"GLSLShader","name":"Image","source":"// Live coded for Inercia Shader Royale 2022 - 3rd place\n\n// You can change this variable if it's too slow\n#define SAMPLE_COUNT 10.\n\n// can also reduce to gain fps\n#define RAYMARCH_DEPTH 100\n\nfloat time;\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nvec3 rnd3(vec3 p) {\n  return fract(sin(p.xyz*724.524+p.yzx*534.824+p.zxy*381.254)*vec3(413.644,388.521,924.532));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*542.521)*824.588);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.), pow(smoothstep(0.,1.,fract(t)),10.));\n}\n\nvec3 loc;\nfloat lum;\nfloat map(vec3 p) {\n  \n  vec3 p2=p;\n  for(float i=0.; i<3.; ++i) {\n    p.xz *= rot(time*.2 + i*1.3 + curve(time/3.)*4. + sin(p.y*.1)*.4);\n    p.yz *= rot(time*.3 - i*.3 - curve(time/6.+7.)*4. + sin(p.x*.2)*.4);\n    //p = abs(p)-vec3(1.3,1.5,0.9)+i*.3 - .5 - sin(time*.3+vec3(7,3,2))*.4;\n    p.xz = abs(p.xz)-vec2(1.3,1.5)+i*.3 - .5 - sin(time*.3+vec2(7,3))*1.0;\n  }\n  \n  \n  float d = box(p, vec3(1,.7,.1));\n  \n  vec3 p3=p;\n  p3.z=max(0.,p3.z-2.);\n  lum=length(p3)-.1;\n  d=min(d,lum);\n  \n  p.xy *= rot(0.785);\n  d=min(d, max(abs(box(p, vec3(.4,.4,3)))-.04, abs(p.z)-1.4));\n  \n  loc=p;\n  \n  p.xz = abs(p.xz)-.3;\n  d=min(d, length(p.xz)-.07);\n  d=min(d, length(p.yz)-.07);\n  \n  d=min(d, length(p2)-3.);\n  \n  \n  return d*0.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n  time=mod(iTime, 300.);\n  \n  uv.y -= curve(time*3.)*.1;\n  uv *= 1.+curve(time*3.+9.)*.3;\n  \n  vec3 mumu=vec3(1);\n  // glitchy glitchy\n  //if(curve(abs(uv.y)*10.+time*30.)<.4-curve(time*4.-abs(uv.y))) {uv=floor(uv*50.)/50.; mumu=vec3(.8,1.3,0.6);}\n  \n  float prog=time/6. - length(uv)*.05;\n  float style=mod(prog*0.5,1.);\n  float scene=floor(prog);\n  \n  time = time*1.3 + rnd(scene)*300.;\n\n  vec3 col=vec3(0);\n  vec3 coco=vec3(0,.4,.8);\n  float t2=time*.2;\n  //coco.xz *= rot(t2);\n  //coco.yz *= rot(t2*.7);\n  \n  const float count = SAMPLE_COUNT;\n  for(float j=0.; j<count; ++j) {\n    \n    vec3 dof=rnd3(vec3(uv+7.+j, fract(time)+j*.2)) * .5;\n    dof.z=0.;\n    vec3 s=vec3(sin(time/20.)*5.,0,-15);\n    s+=dof;\n    float fov=1. + sin(time*.25)*.5;\n    vec3 r=normalize(vec3(uv, fov));\n    r-=dof*.08;\n    \n    vec3 p=s;\n    float alpha=1.;\n    for(int i=0; i<RAYMARCH_DEPTH; ++i) {\n      float d=map(p);\n      if(lum<.1) col += vec3(3,0.3,0.3)*0.0005/(0.0001+abs(lum));\n      \n      if(d<0.001) {\n        vec3 loco=loc;\n        vec2 off=vec2(0.01,0);\n        vec3 n=normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        \n        //col += n;\n        float rough=0.1+0.4*rnd3(floor(loco*8.)).x;\n        if(length(p)<3.1) rough=0.2;\n        vec3 n2=normalize(n+rough*rnd3(vec3(uv+j, fract(time)+j*.1)));\n        \n        r=reflect(r,n2);\n        d=0.1;\n        alpha*=0.3+.6*pow(1.-abs(dot(n,r)),3.);\n      }\n      if(d>100.0) break;\n      p+=r*d;\n      \n    }\n    vec3 sky=5.*max(vec3(0), -.4+sin(r.y*3. + coco + time*1. + sin(r.x*4.+time*.3)));\n    sky = mix(sky, vec3(.9), step(style,.5));\n    col += alpha * sky;\n  }\n  col /= count;\n  \n  col=mix(col, vec3(dot(col, vec3(0.333))), vec3(0.6+sin(time + abs(uv.x)*4.)*.3));\n  col = pow(col,mumu);\n  col *= 1.2-length(uv);\n  \n  col = smoothstep(0.,1.,col);\n  col = pow(col, vec3(0.4545));\n  \n    fragColor = vec4(col, 1);\n}\n","type":"Image"}]}