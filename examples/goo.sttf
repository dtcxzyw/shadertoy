{"links":[{"end":"RenderOutput","filter":"Linear","slot":0,"start":"Image","wrapMode":"Repeat"},{"end":"Image","filter":"Linear","slot":0,"start":"Buf B","wrapMode":"Clamp"},{"end":"Buf B","filter":"Linear","slot":0,"start":"Buf A","wrapMode":"Clamp"}],"metadata":{"Author":"noby","Description":"A quick one evening doodle with semi-translucent material shading.","Name":"Goo","ShaderToyURL":"https://www.shadertoy.com/view/lllBDM"},"nodes":[{"class":"RenderOutput","name":"RenderOutput"},{"class":"GLSLShader","name":"Image","source":"// Tone mapping and post processing\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n// linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q / (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\trf *= 0.9972;\n\t\tgf *= 0.998;\n        bf /= 0.9988;\n\t\tc = clamp(c,0.0, 1.0);\n\t}\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    const float brightness = 1.0;\n    vec2 pp = fragCoord.xy/iResolution.xy;\n    vec2 r = iResolution.xy;\n    vec2 p = 1.-2.*fragCoord.xy/r.xy;\n    p.y *= r.y/r.x;\n   \n    // a little chromatic aberration\n    vec4 sampl = texture(iChannel0, pp);\n    vec3 color = ca(iChannel0, pp, sampl).rgb;\n    \n    // final output\n    float vignette = 1.25 / (1.1 + 1.1*dot(p, p));\n    vignette *= vignette;\n    vignette = mix(1.0, smoothstep(0.1, 1.1, vignette), 0.25);\n    float noise = .012*vec3(hash(length(p)*iTime)).x;\n    color = color*vignette+noise;\n    color = filmic_reinhard(brightness*color);\n    \n    color = smoothstep(-0.025, 1.0,color);\n    \n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.0);\n}\n","type":"Image"},{"class":"GLSLShader","name":"Buf A","source":"// MIT License: https://opensource.org/licenses/MIT\nconst float pi = 3.14159;\nmat3 rotate( in vec3 v, in float angle){\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// Gradient noise from iq\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\nfloat map(vec3 p){\n    // ugly hacky slow distance field with bad gradients\n    float d = p.y;\n    float c = max(0.0, pow(distance(p.xz, vec2(0,16)), 1.0));\n    float cc = pow(smoothstep(20.0, 5.0, c), 2.0);\n    //p.xz *= cc;\n    vec4 n = noised(vec3(p.xz*0.07, iTime*0.5));\n    float nn = n.x * (length((n.yzw)));\n    n = noised(vec3(p.xz*0.173, iTime*0.639));\n    nn += 0.25*n.x * (length((n.yzw)));\n    nn = smoothstep(-0.5, 0.5, nn);\n    d = d-6.0*nn*(cc);\n    return d;\n}\n\nfloat err(float dist){\n    dist = dist/100.0;\n    return min(0.01, dist*dist);\n}\n\nvec3 dr(vec3 origin, vec3 direction, vec3 position){\n    const int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (map(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec3 intersect(vec3 ro, vec3 rd){\n\tvec3 p = ro+rd;\n\tfloat t = 0.;\n\tfor(int i = 0; i < 150; i++){\n        float d = 0.5*map(p);\n        t += d;\n        p += rd*d;\n\t\tif(d < 0.01 || t > 60.0) break;\n\t}\n    \n    // discontinuity reduction as described (somewhat) in\n    // their 2014 sphere tracing paper\n    p = dr(ro, rd, p);\n    return p;\n}\n\nvec3 normal(vec3 p){\n\tfloat e=0.01;\n\treturn normalize(vec3(map(p+vec3(e,0,0))-map(p-vec3(e,0,0)),\n\t                      map(p+vec3(0,e,0))-map(p-vec3(0,e,0)),\n\t                      map(p+vec3(0,0,e))-map(p-vec3(0,0,e))));\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    //vec3 d = normalize(mix(v, -n, 0.5));\n    // suggested by Shane\n    vec3 d = refract(v, n, 1.0/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 2.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = map(o);\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0)/thickness;\n}\n\nvec3 shade(vec3 p, vec3 v){\n    vec3 lp = vec3(50,20,10);\n    vec3 ld = normalize(p+lp);\n    \n    vec3 n = normal(p);\n    float fresnel = pow( max(0.0, 1.0+dot(n, v)), 5.0 );\n    \n    vec3 final = vec3(0);\n    vec3 ambient = vec3(0.1, 0.06, 0.035);\n    vec3 albedo = vec3(0.75, 0.9, 0.35);\n    vec3 sky = vec3(0.5,0.65,0.8)*2.0;\n    \n    float lamb = max(0.0, dot(n, ld));\n    float spec = ggx(n, v, ld, 3.0, fresnel);\n    float ss = max(0.0, subsurface(p, v, n));\n    \n    // artistic license\n    lamb = mix(lamb, 3.5*smoothstep(0.0, 2.0, pow(ss, 0.6)), 0.7);\n    final = ambient + albedo*lamb+ 25.0*spec + fresnel*sky;\n    return vec3(final*0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 a = vec3(0);\n    \n    // leftover stuff from something else, too lazy to remove\n    // don't ask\n    const float campos = 5.1;\n    float lerp = 0.5+0.5*cos(campos*0.4-pi);\n    lerp = smoothstep(0.13, 1.0, lerp);\n    vec3 c = mix(vec3(-0,217,0), vec3(0,4.4,-190), pow(lerp,1.0));\n    mat3 rot = rotate(vec3(1,0,0), pi/2.0);\n    mat3 ro2 = rotate(vec3(1,0,0), -0.008*pi/2.0);\n    \n    vec2 u2 = -1.0+2.0*uv;\n    u2.x *= iResolution.x/iResolution.y;\n\n    vec3 d = mix(normalize(vec3(u2, 20)*rot), normalize(vec3(u2, 20))*ro2, pow(lerp,1.11));\n    d = normalize(d);\n\n    vec3 ii = intersect(c+145.0*d, d);\n    vec3 ss = shade(ii, d);\n    a += ss;\n    \n    fragColor.rgb = a*(0.99+0.02*hash(vec3(uv,0.001*iTime)));\n}\n","type":"Image"},{"class":"GLSLShader","name":"Buf B","source":"// FXAA implementation by mudlord (I think?)\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1.0 / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}\n","type":"Image"}]}