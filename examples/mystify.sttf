{"links":[{"end":"RenderOutput","filter":"Linear","slot":0,"start":"Image","wrapMode":"Repeat"},{"end":"Image","filter":"Linear","slot":0,"start":"Buffer A","wrapMode":"Clamp"},{"end":"Buffer A","filter":"Linear","slot":0,"start":"LastFrame","wrapMode":"Clamp"}],"metadata":{"Author":"Qendolin","Description":"This is supposed to be a clone of the Windows \"Mystify\" screensaver. I guess I got close but you can definitely tell that it's not as good as the original.\n\nMusic: https://soundcloud.com/3kliksphilip/under-the-pizza\n\n","Name":"Mystify Screensaver","ShaderToyURL":"https://www.shadertoy.com/view/MsKcRh"},"nodes":[{"class":"RenderOutput","name":"RenderOutput"},{"class":"GLSLShader","name":"Image","source":"#define PI 3.14159265359\n\nfloat sinNorm(float x)\n{\n    return sin(x)*0.5+0.5;\n}\n\nfloat line(in int lineWidth, in vec2 pos, in vec2 point, in vec3 iResolution) {\n    float normalizedLineRadius = (float(lineWidth) / iResolution.y) / 2.;\n    float edgeWidth = 1. / iResolution.y;\n    if(normalizedLineRadius<1./iResolution.x)\n        return 0.;\n\treturn smoothstep(pos.y-normalizedLineRadius,pos.y-edgeWidth,point.y-normalizedLineRadius+edgeWidth) * \n        (1.-smoothstep(pos.y+normalizedLineRadius-edgeWidth, pos.y+normalizedLineRadius+edgeWidth, point.y));\n}\n\nfloat smoothVal(in float x, in float max) {\n\treturn clamp(smoothstep(0.0,1.0,x/max)*(1.-smoothstep(0.0,1.0,x/max))*4.,0.,1.);\n}\n\n//f(x) = amplitude*sinNormalized(frequency*x-offsetX)+d\nfloat normSinFunct(in float amplitude, in float freq, in float offsetX, in float offsetY, in float x) {\n    return amplitude*sinNorm(freq*x-offsetX)+offsetY;\n}\n\nfloat rand(float seed) {\n    return fract(sin(dot(vec2(seed, seed / PI) ,vec2(12.9898,78.233))) * 43758.5453);   \n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}\n\n","type":"Image"},{"class":"GLSLShader","name":"Buffer A","source":"#define PI 3.14159265359\n\nfloat sinNorm(float x)\n{\n    return sin(x)*0.5+0.5;\n}\n\nfloat line(in int lineWidth, in vec2 pos, in vec2 point, in vec3 iResolution) {\n    float normalizedLineRadius = (float(lineWidth) / iResolution.y) / 2.;\n    float edgeWidth = 1. / iResolution.y;\n    if(normalizedLineRadius<1./iResolution.x)\n        return 0.;\n\treturn smoothstep(pos.y-normalizedLineRadius,pos.y-edgeWidth,point.y-normalizedLineRadius+edgeWidth) * \n        (1.-smoothstep(pos.y+normalizedLineRadius-edgeWidth, pos.y+normalizedLineRadius+edgeWidth, point.y));\n}\n\nfloat smoothVal(in float x, in float max) {\n\treturn clamp(smoothstep(0.0,1.0,x/max)*(1.-smoothstep(0.0,1.0,x/max))*4.,0.,1.);\n}\n\n//f(x) = amplitude*sinNormalized(frequency*x-offsetX)+d\nfloat normSinFunct(in float amplitude, in float freq, in float offsetX, in float offsetY, in float x) {\n    return amplitude*sinNorm(freq*x-offsetX)+offsetY;\n}\n\nfloat rand(float seed) {\n    return fract(sin(dot(vec2(seed, seed / PI) ,vec2(12.9898,78.233))) * 43758.5453);   \n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n    \n//Make random values more random\nfloat randSeed = 0.;\n\n#define FLOORI(x) float(int(floor(x)))\n\n/* old function\nfloat smoothRand(float interval, float seed) {\n    float next = rand(1.+floor(iTime/interval)+seed);\n    float curr = rand(floor(iTime/interval)+seed);\n    randSeed++;\n    return mix(curr, next, fract(iTime/interval));\n}\n*/\n\nfloat smoothRand(float interval, float seed) {\n    float next = rand(.000001*FLOORI(1000000.*(1.+FLOORI(iTime/interval)+seed+randSeed)));\n    float curr = rand(.000001*FLOORI(1000000.*(FLOORI(iTime/interval)+seed+randSeed)));\n    randSeed++;\n    return mix(curr, next, fract(iTime/interval));\n}\n\nfloat f(vec2 point) {\n\treturn sin(point.x*2.+iTime*1.275)+point.y;   \n}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\n//https://iquilezles.org/articles/distance\nfloat color( in vec2 point, in int lineWidth, in vec3 iResolution)\n{\n    float v = f( point );\n    vec2  g = grad( point );\n    float de = abs(v)/length(g);\n    float normalizedLineRadius = (float(max(5,lineWidth)) / iResolution.y) / 2.;\n    float edgeWidth = 1. / iResolution.y;\n    if(normalizedLineRadius<1./iResolution.x)\n        return 0.;\n    float eps = max(1./iResolution.x, 1./iResolution.y)*normalizedLineRadius;\n    return 1.-clamp(smoothstep( 0., normalizedLineRadius, de ), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //init\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 point = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tpoint = 2.0 * point.xy / iResolution.y;\n    float x,y,z = 0.;\n    fragColor = vec4(0);\n \n    //Limit \"frames\" for uniterrupted animation\n    float frameRatio = floor(iFrameRate/ 30.);\n    if(mod(float(iFrame), frameRatio) != 0.) {\n        float decay = sinNorm(iTime*0.789)*0.5+0.1;\n        fragColor += texture(iChannel0, uv) * (1.-(1./(decay*iFrameRate)));\n\n        //Clamp to prevent overexposure\n        fragColor.r = clamp(fragColor.r, 0., 1.);\n        fragColor.g = clamp(fragColor.g, 0., 1.);\n        fragColor.b = clamp(fragColor.b, 0., 1.);\n        return;   \n    }\n    \n    //Scaling\n    const float maxZoom = 1.5;\n    const float minZoom = 0.5;\n    const float changeInterval = 2.;\n    float nextZ = rand(1.+floor(iTime/changeInterval));\n    float currZ = rand(floor(iTime/changeInterval));\n    z=minZoom+(maxZoom-minZoom)*mix(currZ, nextZ, fract(iTime/changeInterval));\n    point/=vec2(z);\n    \n    //Rotation\n    float rot = smoothRand(0.5,354.856)*PI;\n    point=vec2(cos(rot)*point.x+sin(rot)*point.y, -sin(rot)*point.x+cos(rot)*point.y);\n    \n    //Translation\n    point.x+=smoothRand(1.,842.546)*2.-1.;\n    //No need to translate y here, bc y is set by the function in \"f(point)\" and the rotation.\n    \n    //Line\n    const float minLength = 0.25;\n    const float maxLength=0.5;\n    float lineLength=minLength+smoothRand(4.,0.846)*(maxLength-minLength)+minLength;\n    float linePoint = (point.x+lineLength/2.) / lineLength;\n    //\t\t\t\tclamp - make sure the value is in bounds\n    //\t\t\t\t\t\t  smoothVal - make the line thinner at the ends\n    int lineWidth = int(clamp(floor(smoothVal(linePoint*100., 100.)*iResolution.x*0.025*z), 2., floor(iResolution.x*0.025*z)));//max(3,int((iResolution.x*0.1)*  pow((point.x*(1./lineLength)),3.)  ));\n    if(point.x >= -lineLength / 2. && point.x <= lineLength / 2.) { //Only show a small segment\n    \tfragColor+=color(vec2(point.x,point.y), lineWidth, iResolution);//line(lineWidth, vec2(x,y), point, iResolution);\n\t}\t\n    /*if(point.x-x<0.005) {\n        fragColor = vec4(1.);\n    }\n    if(point.y-y<0.005) {\n\t\t//fragColor = vec4(1.);\n    }*/\n    //Color\n    fragColor.rgb*=hsv2rgb(vec3(fract(iTime/7.), sinNorm(iTime*rand(135.54))*0.4+0.6,1.));\n    fragColor.rgb+=pow((fragColor.r+fragColor.g+fragColor.b)/3.+0.25,3.)-pow(0.25,3.);\n    \n    //Fade\n    float decay = sinNorm(iTime*0.789)*0.5+0.25;\n    fragColor += texture(iChannel0, uv) * (1.-(1./(decay*iFrameRate)));\n    \n    //Clamp to prevent overexposure\n    fragColor.r = clamp(fragColor.r, 0., 2.);\n    fragColor.g = clamp(fragColor.g, 0., 2.);\n    fragColor.b = clamp(fragColor.b, 0., 2.);\n    fragColor.a = 0.;\n}\n\n","type":"Image"},{"class":"LastFrame","name":"LastFrame","ref":"Buffer A","type":"Image"}]}